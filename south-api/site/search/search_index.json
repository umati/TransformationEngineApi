{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"umati Transformation Engine Foreword The VDW-Forschungsinstitut e.V. is currently working with partners and its members to create a specification of a TransformationEngine. This document describes the development process and the decisions made to develop the first API. Currently this is designed to be implemented in C to allow the application on any necessary platform and device. Application Warning Notice This DRAFT with date of issue 2021-10-01 is being submitted to the public for review and comment. Because the final API Specification may differ from this version, the application of this draft is subject to special agreement. Comments are requested: preferably as a file by e-mail to g.goerisch@vdw.de or in paper form to VDW-Forschungsinstitut e.V., Lyoner Stra\u00dfe 18, 60528 Frankfurt Partners Bridgefield (Magdeburg) iT Engineering Software Innovations (Pliezhausen) Pragmatic Minds (Kirchheim/Teck) Machine Tool Builders CHIRON Group (Tuttlingen) DMG Mori (Pfronten) EMAG (Salach) GROB Werke (Mindelheim) Gebr. Heller (N\u00fcrtingen) Liebherr Verzahntechnik (Kempten) Trumpf Werkzeugmaschinen (Ditzingen) United Grinding Group (Bern) Glossary API Application Programming Interface DC Data Client Data Source Actual OEM data source or controller of manufacturing machine which is accessible by a south API compatible data client implementation North API 'north bound' API to be used to provided data and functionality from transformation engine to a connected OPC UA server OPC UA OPC Unified Architecture: machine to machine communication protocol for industrial automation South API 'south bound' API to be used to integrate data sources in transformation engines TE Transformation Engine Purpose and Scope The OPC UA Server with the OPC 40501-1 UA for Machine Tools companion specification on the north side of the stack is the access for OPC-UA clients on machine or factory level which can communicate to local MES/PPS/ERP or cloud services. The Data Clients on the south side of the stack are the different sources and sinks for data and machining functions, i.e. these blocks may be for example NCs, PLC, IPCs and \u201cintelligent\u201d sensors or actuators in the machine. In most cases, all these sinks and sources provide non-standardized, proprietary interfaces. Hence, the objective of the proposed TransformationEngine is to transfer and convert data and commands between the OPC UA Server on the north side of the stack and the data clients on the south side. As an important requirement, the conversion must be provided in a standardized way. This document describes the requirements on this standardization. Further details on the functionality of the different components in the stack and on single requirements are given below. Figure 1 - Conceptual design of the TE System context This is a simplified description of the system context the South API specification, defined here and in accompanying header files, is intended to be used in. Container diagram This diagram describes possible Transformation Engine implementation containers assumed/anticipated by this specification. The term container in this context is used for separately running applications native to the target platform ( see also: C4 Model ). For reference: The South API is intended to be used for either directly connecting the transformation engine with an OEM data client or indirectly through a separate data client wrapper . The OPC UA server and OEM data client are marked as external in this diagram to symbolize different implementation responsiblities. It is expected to have deployment scenarios where transformation engine and data client wrapper are implemented by the same implementor and combined with 3rd party OEM data client and OPC UA server implementations, which is why a South API definition and later a North API definition are needed in the first place. Architectural Drivers The API design is mainly guided by the following selection of architectural drivers for now. criteria meaning in project context extensibility multiple different data clients must be supported by a single transformation engine availability implementing data clients must be easy and not require special runtimes or tools portability I implementing data clients must not require OPC UA portability II chosen data client technology must at least enable Windows and Linux host systems reusability implemented data clients must be usable by different transformation engine implementations Decisions summary The current South API is mainly based on decisions described in the table below. Apart from these decisions certain parts of the OPC UA specification were also used. These are mentioned and linked explicitly from the actual South API specification. The impact of these references was carefully limited to not add additional dependencies for data client implementors (see portability I criteria) and mainly used to simplify later interactions between data clients and a North API that will be more reliant on OPC UA specifications. number problem to solve decision state 001 interface type stdcall C interface accepted 002 api artifacts only c header file(s) accepted 003 read access select fields to read accepted 004 threading model Async data client API accepted 005 error codes Same error type for all methods accepted 006 text encoding UTF-8 accepted 007 memory allocation no ownership transfer accepted 008 configuration structure separate files for each client accepted 009 data client model access data client registers model at TEK accepted 010 OPC UA data source integration assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration accepted 011 Metadata Transport metadata information from data source to TEK WIP Newly defined architectural drivers and or requirements from other sources might require decisions to be reevaluated.","title":"Overview"},{"location":"index.html#umati-transformation-engine","text":"","title":"umati Transformation Engine"},{"location":"index.html#foreword","text":"The VDW-Forschungsinstitut e.V. is currently working with partners and its members to create a specification of a TransformationEngine. This document describes the development process and the decisions made to develop the first API. Currently this is designed to be implemented in C to allow the application on any necessary platform and device. Application Warning Notice This DRAFT with date of issue 2021-10-01 is being submitted to the public for review and comment. Because the final API Specification may differ from this version, the application of this draft is subject to special agreement. Comments are requested: preferably as a file by e-mail to g.goerisch@vdw.de or in paper form to VDW-Forschungsinstitut e.V., Lyoner Stra\u00dfe 18, 60528 Frankfurt Partners Bridgefield (Magdeburg) iT Engineering Software Innovations (Pliezhausen) Pragmatic Minds (Kirchheim/Teck) Machine Tool Builders CHIRON Group (Tuttlingen) DMG Mori (Pfronten) EMAG (Salach) GROB Werke (Mindelheim) Gebr. Heller (N\u00fcrtingen) Liebherr Verzahntechnik (Kempten) Trumpf Werkzeugmaschinen (Ditzingen) United Grinding Group (Bern)","title":"Foreword"},{"location":"index.html#glossary","text":"API Application Programming Interface DC Data Client Data Source Actual OEM data source or controller of manufacturing machine which is accessible by a south API compatible data client implementation North API 'north bound' API to be used to provided data and functionality from transformation engine to a connected OPC UA server OPC UA OPC Unified Architecture: machine to machine communication protocol for industrial automation South API 'south bound' API to be used to integrate data sources in transformation engines TE Transformation Engine","title":"Glossary"},{"location":"index.html#purpose-and-scope","text":"The OPC UA Server with the OPC 40501-1 UA for Machine Tools companion specification on the north side of the stack is the access for OPC-UA clients on machine or factory level which can communicate to local MES/PPS/ERP or cloud services. The Data Clients on the south side of the stack are the different sources and sinks for data and machining functions, i.e. these blocks may be for example NCs, PLC, IPCs and \u201cintelligent\u201d sensors or actuators in the machine. In most cases, all these sinks and sources provide non-standardized, proprietary interfaces. Hence, the objective of the proposed TransformationEngine is to transfer and convert data and commands between the OPC UA Server on the north side of the stack and the data clients on the south side. As an important requirement, the conversion must be provided in a standardized way. This document describes the requirements on this standardization. Further details on the functionality of the different components in the stack and on single requirements are given below. Figure 1 - Conceptual design of the TE","title":"Purpose and Scope"},{"location":"index.html#system-context","text":"This is a simplified description of the system context the South API specification, defined here and in accompanying header files, is intended to be used in.","title":"System context"},{"location":"index.html#container-diagram","text":"This diagram describes possible Transformation Engine implementation containers assumed/anticipated by this specification. The term container in this context is used for separately running applications native to the target platform ( see also: C4 Model ). For reference: The South API is intended to be used for either directly connecting the transformation engine with an OEM data client or indirectly through a separate data client wrapper . The OPC UA server and OEM data client are marked as external in this diagram to symbolize different implementation responsiblities. It is expected to have deployment scenarios where transformation engine and data client wrapper are implemented by the same implementor and combined with 3rd party OEM data client and OPC UA server implementations, which is why a South API definition and later a North API definition are needed in the first place.","title":"Container diagram"},{"location":"index.html#architectural-drivers","text":"The API design is mainly guided by the following selection of architectural drivers for now. criteria meaning in project context extensibility multiple different data clients must be supported by a single transformation engine availability implementing data clients must be easy and not require special runtimes or tools portability I implementing data clients must not require OPC UA portability II chosen data client technology must at least enable Windows and Linux host systems reusability implemented data clients must be usable by different transformation engine implementations","title":"Architectural Drivers"},{"location":"index.html#decisions-summary","text":"The current South API is mainly based on decisions described in the table below. Apart from these decisions certain parts of the OPC UA specification were also used. These are mentioned and linked explicitly from the actual South API specification. The impact of these references was carefully limited to not add additional dependencies for data client implementors (see portability I criteria) and mainly used to simplify later interactions between data clients and a North API that will be more reliant on OPC UA specifications. number problem to solve decision state 001 interface type stdcall C interface accepted 002 api artifacts only c header file(s) accepted 003 read access select fields to read accepted 004 threading model Async data client API accepted 005 error codes Same error type for all methods accepted 006 text encoding UTF-8 accepted 007 memory allocation no ownership transfer accepted 008 configuration structure separate files for each client accepted 009 data client model access data client registers model at TEK accepted 010 OPC UA data source integration assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration accepted 011 Metadata Transport metadata information from data source to TEK WIP Newly defined architectural drivers and or requirements from other sources might require decisions to be reevaluated.","title":"Decisions summary"},{"location":"changelog.html","text":"Changelog Future changes standard events behavior of alarms at connect/reconnect sampling-rate unregister_* methods WIP: proposal timeout/progress/cancel WIP: proposal error codes WIP: data client items metadata Current Version consistent method signatures (return a TEK_SA_RESULT , generated handles etc. passed as out parameter) all array dimensions and counts now have type uint32_t (as size_t is implementation defined) introduced struct tek_sa_configuration which defines the global timeout value (and may be extended later) defined struct member offsets and check them at compile time verified standard ISO/IEC 9899:1990 (C90) and ISO/IEC 14882:1998 (C++98) conformance improved documentation code formatting rules created and applied Release 0.9.0 published generated documentation improved and extended documentation restructured documentation of decisions concerning the API architecture documentation of all API items consistent naming off all API items ( tek_sa_ resp. TEK_SA_ ) PG Meeting 2021/09/06","title":"Changelog"},{"location":"changelog.html#changelog","text":"","title":"Changelog"},{"location":"changelog.html#future-changes","text":"standard events behavior of alarms at connect/reconnect sampling-rate unregister_* methods WIP: proposal timeout/progress/cancel WIP: proposal error codes WIP: data client items metadata","title":"Future changes"},{"location":"changelog.html#current-version","text":"consistent method signatures (return a TEK_SA_RESULT , generated handles etc. passed as out parameter) all array dimensions and counts now have type uint32_t (as size_t is implementation defined) introduced struct tek_sa_configuration which defines the global timeout value (and may be extended later) defined struct member offsets and check them at compile time verified standard ISO/IEC 9899:1990 (C90) and ISO/IEC 14882:1998 (C++98) conformance improved documentation code formatting rules created and applied","title":"Current Version"},{"location":"changelog.html#release-090","text":"published generated documentation improved and extended documentation restructured documentation of decisions concerning the API architecture documentation of all API items consistent naming off all API items ( tek_sa_ resp. TEK_SA_ )","title":"Release 0.9.0"},{"location":"changelog.html#pg-meeting-20210906","text":"","title":"PG Meeting 2021/09/06"},{"location":"decisions/001-dataclient-interface-type.html","text":"001 Type of the interface (Socket, shared library or managed code) Status: accepted Deciders: partners Context and Problem Statement What is the type of communication between the data client (DC) and the transformation engine (TE)? Should we force a network protocol or is it better to use in-process communication? Decision Drivers supportability: data clients can be easily implemented by a sensor/tool manufacturer reusability: data clients can be integrated into different TE implementations availability: Language for TE implementations are not unnecessarily restricted portability: minimum supported OS are Windows, Linux (POSIX combatible) Considered Options Socket/interprocess communication stdcall C interface dotnet/java interface Decision Outcome stdcall C interface Positive Consequences no restrictions for TE implementations managed runtimes as well as native code can access stdcall binaries Negative Consequences The implementation language of the DC is restricted to a language which is compilable to native machine code. The data client implementation may influence the stability of the TE The platforms a data client can be used at depends on the manufacturer of the controller/sensor. Pros and Cons of the Options Socket/interprocess communication The data client is running as a separate process on the same or a different machine and is accessible via a custom network protocol. Good, because dataclient is completely independent runtime environment from TE Good, because a faulty data client cannot crash the TE Bad, because it requires a complex binary protocol Bad, because additional delays for inter process communication must be considered Bad, because of overall system complexity due to multiple running processes stdcall C interface The data client is realized as a shared library (.DLL on Windows, .so on *ix) which is loaded into the TEK process. Good, because all imaginable TE implementation languages can load C libraries Good, because it is supported on every sensible operating system and processor architecture Good, because it has nearly no communication overhead Good, because a socket interface can be added easily if ever needed Bad, because manufacturer must provided different implementations for all supported platforms Bad, because the implementation might be more complex than a Java/CLR implementation Bad, because the DC code runs in the process of the TEK and may influence its stability dotnet/java interface Use a common managed runtime like dotnet CLR, Java Virtual Machine or a Python interpreter to be able to limit the required effort to provide data client binaries for all supported platforms. Good, because implementation might be easier for a given manufacturer Good, because one data client runs on every platform Bad, because only platforms with existing Java/CLR runtime are supported Bad, because it limits the implementation languge to the languages available on the CLR/JVM","title":"001 Type of the interface (Socket, shared library or managed code)"},{"location":"decisions/001-dataclient-interface-type.html#001-type-of-the-interface-socket-shared-library-or-managed-code","text":"Status: accepted Deciders: partners","title":"001 Type of the interface (Socket, shared library or managed code)"},{"location":"decisions/001-dataclient-interface-type.html#context-and-problem-statement","text":"What is the type of communication between the data client (DC) and the transformation engine (TE)? Should we force a network protocol or is it better to use in-process communication?","title":"Context and Problem Statement"},{"location":"decisions/001-dataclient-interface-type.html#decision-drivers","text":"supportability: data clients can be easily implemented by a sensor/tool manufacturer reusability: data clients can be integrated into different TE implementations availability: Language for TE implementations are not unnecessarily restricted portability: minimum supported OS are Windows, Linux (POSIX combatible)","title":"Decision Drivers"},{"location":"decisions/001-dataclient-interface-type.html#considered-options","text":"Socket/interprocess communication stdcall C interface dotnet/java interface","title":"Considered Options"},{"location":"decisions/001-dataclient-interface-type.html#decision-outcome","text":"stdcall C interface","title":"Decision Outcome"},{"location":"decisions/001-dataclient-interface-type.html#positive-consequences","text":"no restrictions for TE implementations managed runtimes as well as native code can access stdcall binaries","title":"Positive Consequences "},{"location":"decisions/001-dataclient-interface-type.html#negative-consequences","text":"The implementation language of the DC is restricted to a language which is compilable to native machine code. The data client implementation may influence the stability of the TE The platforms a data client can be used at depends on the manufacturer of the controller/sensor.","title":"Negative Consequences "},{"location":"decisions/001-dataclient-interface-type.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/001-dataclient-interface-type.html#socketinterprocess-communication","text":"The data client is running as a separate process on the same or a different machine and is accessible via a custom network protocol. Good, because dataclient is completely independent runtime environment from TE Good, because a faulty data client cannot crash the TE Bad, because it requires a complex binary protocol Bad, because additional delays for inter process communication must be considered Bad, because of overall system complexity due to multiple running processes","title":"Socket/interprocess communication"},{"location":"decisions/001-dataclient-interface-type.html#stdcall-c-interface","text":"The data client is realized as a shared library (.DLL on Windows, .so on *ix) which is loaded into the TEK process. Good, because all imaginable TE implementation languages can load C libraries Good, because it is supported on every sensible operating system and processor architecture Good, because it has nearly no communication overhead Good, because a socket interface can be added easily if ever needed Bad, because manufacturer must provided different implementations for all supported platforms Bad, because the implementation might be more complex than a Java/CLR implementation Bad, because the DC code runs in the process of the TEK and may influence its stability","title":"stdcall C interface"},{"location":"decisions/001-dataclient-interface-type.html#dotnetjava-interface","text":"Use a common managed runtime like dotnet CLR, Java Virtual Machine or a Python interpreter to be able to limit the required effort to provide data client binaries for all supported platforms. Good, because implementation might be easier for a given manufacturer Good, because one data client runs on every platform Bad, because only platforms with existing Java/CLR runtime are supported Bad, because it limits the implementation languge to the languages available on the CLR/JVM","title":"dotnet/java interface"},{"location":"decisions/002-api-artifacts.html","text":"002 API artifacts Status: accepted Deciders: partners Context and Problem Statement Which artifacts must be provided to data client implementors? Decision Drivers extensibility: how easy is it to integrate new data clients upgradability: how much must be done to switch to new API versions usability: how easily can errors in the custom scrips and in the configuration be detected Considered Options c header file(s) and shared library only c header file(s) Decision Outcome only c header file(s) Pros and Cons of the Options c header file(s) and shared library Data client implementations can use c header files and also a library implementing TEK functions called from data clients. Good, because the execution flow is easily understandable (less usage of callback functions) Good, because the interface is easier to read and understand Bad, because it binds the data client to a specific south API binary Bad, because all TEK implementations are bound to a specific south API binary Bad, because backwards compatibility of binary and header files must be considered only c header file(s) Data client implementations use c header files containing among other definitions a function pointer based definition of TEK functions called from data clients. An instance of a TEK interface is then provided to a data client on start up. i.e.: interface tek { // ... void notify_event ( data_client ,...); void notify_condition ( data_client ,...); // ... }; Good, because no binary dependency for data clients Good, because no binary dependency for TEK implementations Good, because backwards compatibility only for header files must be considered Bad, because it may be more difficult to handle function pointers instead of direct library calls Remarks Wrapping managed (Java, CLR) data client implementations with native wrappers In case an already existing basic managed data client library exists where a complete rewrite with native C code would be too much of a hassle there is the possibility/necessity of wrapping managed libraries with the proposed C south API for the transformation engine. This may be done as separately started processes or by using the integration apis: JVM CLR","title":"002 API artifacts"},{"location":"decisions/002-api-artifacts.html#002-api-artifacts","text":"Status: accepted Deciders: partners","title":"002 API artifacts"},{"location":"decisions/002-api-artifacts.html#context-and-problem-statement","text":"Which artifacts must be provided to data client implementors?","title":"Context and Problem Statement"},{"location":"decisions/002-api-artifacts.html#decision-drivers","text":"extensibility: how easy is it to integrate new data clients upgradability: how much must be done to switch to new API versions usability: how easily can errors in the custom scrips and in the configuration be detected","title":"Decision Drivers"},{"location":"decisions/002-api-artifacts.html#considered-options","text":"c header file(s) and shared library only c header file(s)","title":"Considered Options"},{"location":"decisions/002-api-artifacts.html#decision-outcome","text":"only c header file(s)","title":"Decision Outcome"},{"location":"decisions/002-api-artifacts.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/002-api-artifacts.html#c-header-files-and-shared-library","text":"Data client implementations can use c header files and also a library implementing TEK functions called from data clients. Good, because the execution flow is easily understandable (less usage of callback functions) Good, because the interface is easier to read and understand Bad, because it binds the data client to a specific south API binary Bad, because all TEK implementations are bound to a specific south API binary Bad, because backwards compatibility of binary and header files must be considered","title":"c header file(s) and shared library"},{"location":"decisions/002-api-artifacts.html#only-c-header-files","text":"Data client implementations use c header files containing among other definitions a function pointer based definition of TEK functions called from data clients. An instance of a TEK interface is then provided to a data client on start up. i.e.: interface tek { // ... void notify_event ( data_client ,...); void notify_condition ( data_client ,...); // ... }; Good, because no binary dependency for data clients Good, because no binary dependency for TEK implementations Good, because backwards compatibility only for header files must be considered Bad, because it may be more difficult to handle function pointers instead of direct library calls","title":"only c header file(s)"},{"location":"decisions/002-api-artifacts.html#remarks","text":"","title":"Remarks"},{"location":"decisions/002-api-artifacts.html#wrapping-managed-java-clr-data-client-implementations-with-native-wrappers","text":"In case an already existing basic managed data client library exists where a complete rewrite with native C code would be too much of a hassle there is the possibility/necessity of wrapping managed libraries with the proposed C south API for the transformation engine. This may be done as separately started processes or by using the integration apis: JVM CLR","title":"Wrapping managed (Java, CLR) data client implementations with native wrappers"},{"location":"decisions/003-read-access.html","text":"003 Granularity of read access of data clients Status: accepted Deciders: partners Context and Problem Statement Due to a very heterogenous system landscape with multiple different data sources we need to define a read access API which can be realized for all data sources. Decision Drivers supportability: data clients can be easily implemented by a sensor/tool manufacturer usability: allow easy access to multiple values consistency: enable synchronized/consistent access to related values Considered Options Only single values/fields can be read Complete state is read at once Select values/fields to read Decision Outcome Select values/fields to read This option was choosen even though it might require more effort when implementing data clients to have a simple and at the same time more versatile API. Positive Consequences the other two options can be easily covered by corresponding selections over single fields or the complete state data clients are responsible to return a consistent state of all the variables requested while the TEK is responsible to request all variables which need to be consistent with only one call Negative Consequences a slightly increased complexity in the implementation of the DC (compared to the first option), especially concerning error handling Pros and Cons of the Options Only single values/fields can be read The data client provides a callback for single fields. bool ( * data_client_read_callback )( data_client dc , field_handle field , struct read_result * result ); Good, because read access is simple Good, because data client must not handle consistent read access Good, because read error handling is field specific Bad, because overhead in TE when accessing multiple fields Bad, because additional APIs are required to enable consistent access to multiple values (i.e. some kind of transaction mechanism) Complete state is read at once The data client provides a callback for the complete current state of the data source. bool ( * data_client_read_callback )( data_client dc , struct read_result ** results , int * read_results_count ); Good, because no separate synchronization is required in the API Bad, because can return more data than needed by the TEK Bad, because data client must handle read access synchronization Bad, because error handling for read errors is more complex Select values/fields to read The data client provides a callback which supports selection of values/fields to read. bool ( * data_client_read_callback )( data_client dc , field_handle * fields , size_t fields_size , struct read_result * results ); Good, because no separate synchronization is required in the API Good, because returns exactly the data needed by the TEK Good, because single field read access can be covered by the same callback Good, because the memory management is done completely in the TEK Bad, because data client must handle read access synchronization Bad, because error handling for read errors is more complex","title":"003 Granularity of read access of data clients"},{"location":"decisions/003-read-access.html#003-granularity-of-read-access-of-data-clients","text":"Status: accepted Deciders: partners","title":"003 Granularity of read access of data clients"},{"location":"decisions/003-read-access.html#context-and-problem-statement","text":"Due to a very heterogenous system landscape with multiple different data sources we need to define a read access API which can be realized for all data sources.","title":"Context and Problem Statement"},{"location":"decisions/003-read-access.html#decision-drivers","text":"supportability: data clients can be easily implemented by a sensor/tool manufacturer usability: allow easy access to multiple values consistency: enable synchronized/consistent access to related values","title":"Decision Drivers"},{"location":"decisions/003-read-access.html#considered-options","text":"Only single values/fields can be read Complete state is read at once Select values/fields to read","title":"Considered Options"},{"location":"decisions/003-read-access.html#decision-outcome","text":"Select values/fields to read This option was choosen even though it might require more effort when implementing data clients to have a simple and at the same time more versatile API.","title":"Decision Outcome"},{"location":"decisions/003-read-access.html#positive-consequences","text":"the other two options can be easily covered by corresponding selections over single fields or the complete state data clients are responsible to return a consistent state of all the variables requested while the TEK is responsible to request all variables which need to be consistent with only one call","title":"Positive Consequences"},{"location":"decisions/003-read-access.html#negative-consequences","text":"a slightly increased complexity in the implementation of the DC (compared to the first option), especially concerning error handling","title":"Negative Consequences"},{"location":"decisions/003-read-access.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/003-read-access.html#only-single-valuesfields-can-be-read","text":"The data client provides a callback for single fields. bool ( * data_client_read_callback )( data_client dc , field_handle field , struct read_result * result ); Good, because read access is simple Good, because data client must not handle consistent read access Good, because read error handling is field specific Bad, because overhead in TE when accessing multiple fields Bad, because additional APIs are required to enable consistent access to multiple values (i.e. some kind of transaction mechanism)","title":"Only single values/fields can be read"},{"location":"decisions/003-read-access.html#complete-state-is-read-at-once","text":"The data client provides a callback for the complete current state of the data source. bool ( * data_client_read_callback )( data_client dc , struct read_result ** results , int * read_results_count ); Good, because no separate synchronization is required in the API Bad, because can return more data than needed by the TEK Bad, because data client must handle read access synchronization Bad, because error handling for read errors is more complex","title":"Complete state is read at once"},{"location":"decisions/003-read-access.html#select-valuesfields-to-read","text":"The data client provides a callback which supports selection of values/fields to read. bool ( * data_client_read_callback )( data_client dc , field_handle * fields , size_t fields_size , struct read_result * results ); Good, because no separate synchronization is required in the API Good, because returns exactly the data needed by the TEK Good, because single field read access can be covered by the same callback Good, because the memory management is done completely in the TEK Bad, because data client must handle read access synchronization Bad, because error handling for read errors is more complex","title":"Select values/fields to read"},{"location":"decisions/004-threading-model.html","text":"004 Data client threading model Status: accepted Deciders: partners Context and Problem Statement Most NC/PLC/Sensor communication involves network communication which is inherently asynchronous. There are however existing communication libraries for some of the communication targets which only support blocking synchronous calls. To be able to support both types of communication we need to select a threading model for data clients which makes it equally easy to implement synchronous and asynchronous data clients. The selected threading model is intended to be used by data client wrapper implementations for encapsulating access to data clients. Hint: The requirements concerning file/block transfer, events and methods have to be evaluated separately. Decision Drivers supportability: data clients can be easily implemented by a sensor/tool manufacturer reusability: data clients can be integrated into different TE implementations flexibility: async and sync data clients must be supported Decision Outcome Async data client API Pros and Cons of the Options Single threaded access Data clients can only be accessed in a single thread. Good, because data clients can be implemented more easily Good, because async calls can always be mapped to blocking synchronous calls when the underlying data connection is async Bad, because threads will be blocked because of I/O waits Bad, because of performance loss Multi threaded access Data clients can be concurrently accessed from multiple threads. Good, because maxiumum performance can be achieved when accessing async data clients Bad, because even strict single threaded data clients need to implement access synchronization Async data client API Data clients have an async API where data is returned with call back methods. On initialization, a data client indicates whether it supports multithreaded calls. If a data client indicates single threaded operation only, the TEK must respect this and call the data client sequentially. See struct dataclient_capabilities . e.g.: enum ASYNC_RESULT { ACCEPTED , // request was accepted and will be executed asynchronously RETRY_LATER , // another request is in progress, can not execute this request INVALID , // can not execute due to request errors COMPLETED // request was completed synchronously }; enum ASYNC_RESULT read ( DC dc , TEK tek , long request_id , struct FIELD * items_to_read , size_t number_of_items ); /// TEK callback from DC void read_progress ( DC dc , long request_id , size_t current_count ); void read_result ( DC dc , long request_id , enum RESULT result , struct FIELD_RESULT * result_data ); Good, because async data clients can use async data access Good, because single threaded clients are explicitly allowed to block and call callback functions while function is running and thus map async call to a sync call without affecting async data clients","title":"004 Data client threading model"},{"location":"decisions/004-threading-model.html#004-data-client-threading-model","text":"Status: accepted Deciders: partners","title":"004 Data client threading model"},{"location":"decisions/004-threading-model.html#context-and-problem-statement","text":"Most NC/PLC/Sensor communication involves network communication which is inherently asynchronous. There are however existing communication libraries for some of the communication targets which only support blocking synchronous calls. To be able to support both types of communication we need to select a threading model for data clients which makes it equally easy to implement synchronous and asynchronous data clients. The selected threading model is intended to be used by data client wrapper implementations for encapsulating access to data clients. Hint: The requirements concerning file/block transfer, events and methods have to be evaluated separately.","title":"Context and Problem Statement"},{"location":"decisions/004-threading-model.html#decision-drivers","text":"supportability: data clients can be easily implemented by a sensor/tool manufacturer reusability: data clients can be integrated into different TE implementations flexibility: async and sync data clients must be supported","title":"Decision Drivers"},{"location":"decisions/004-threading-model.html#decision-outcome","text":"Async data client API","title":"Decision Outcome"},{"location":"decisions/004-threading-model.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/004-threading-model.html#single-threaded-access","text":"Data clients can only be accessed in a single thread. Good, because data clients can be implemented more easily Good, because async calls can always be mapped to blocking synchronous calls when the underlying data connection is async Bad, because threads will be blocked because of I/O waits Bad, because of performance loss","title":"Single threaded access"},{"location":"decisions/004-threading-model.html#multi-threaded-access","text":"Data clients can be concurrently accessed from multiple threads. Good, because maxiumum performance can be achieved when accessing async data clients Bad, because even strict single threaded data clients need to implement access synchronization","title":"Multi threaded access"},{"location":"decisions/004-threading-model.html#async-data-client-api","text":"Data clients have an async API where data is returned with call back methods. On initialization, a data client indicates whether it supports multithreaded calls. If a data client indicates single threaded operation only, the TEK must respect this and call the data client sequentially. See struct dataclient_capabilities . e.g.: enum ASYNC_RESULT { ACCEPTED , // request was accepted and will be executed asynchronously RETRY_LATER , // another request is in progress, can not execute this request INVALID , // can not execute due to request errors COMPLETED // request was completed synchronously }; enum ASYNC_RESULT read ( DC dc , TEK tek , long request_id , struct FIELD * items_to_read , size_t number_of_items ); /// TEK callback from DC void read_progress ( DC dc , long request_id , size_t current_count ); void read_result ( DC dc , long request_id , enum RESULT result , struct FIELD_RESULT * result_data ); Good, because async data clients can use async data access Good, because single threaded clients are explicitly allowed to block and call callback functions while function is running and thus map async call to a sync call without affecting async data clients","title":"Async data client API"},{"location":"decisions/005-error-codes.html","text":"005 Error codes definition Status: accepted Deciders: partners Context and Problem Statement We need to define a common set of error codes for all API calls to enable better diagnostics in case of runtime errors. Decision Drivers ?? Decision Outcome Same error type for all methods Pros and Cons of the Options Same error type for all methods e.g. typedef int SOUTH_API_RESULT ; #define SOUTH_API_SUCCESS 0 #define SOUTH_API_UNKNOWN_VARIABLE 1 #define SOUTH_API_WRONG_ADDRESS 2 Good, because this is the usual way of defining error codes in C Good, because this is directly supported in C Bad, because there is no diffentiation between different classes of api functions. Error codes to be expected have to be declared in comments. One error type for each class of functions e.g. enum READ_RESULT { READ_RESULT_SUCCESS = 0 READ_RESULT_UNKNOWN = 1 }; enum WRITE_RESULT { WRITE_RESULT_SUCCESS = 0 WRITE_RESULT_WRONG_ADDRESS = 1 }; enum CONNECT_RESULT { CONNECT_RESULT_SUCCESS = 0 CONNECT_RESULT_WRONG_ADDRESS = 1 }; Good, because error types to expect are declared expicitely Bad, because of very long names due to missing namespace support in C Bad, because writing log messages becomes hard Bad, because error handling is case to case for each function One error type for each class of functions but the error codes are the same e.g. #define ERR_SUCCESS 0 #define ERR_WRONG_ADDRESS 200 #define ERR_UNKNOWN_VARIABLE 300 enum READ_RESULT { READ_RESULT_SUCCESS = ERR_SUCCESS , READ_RESULT_UNKNOWN = ERR_UNKNOWN_VARIABLE }; enum WRITE_RESULT { WRITE_RESULT_SUCCESS = ERR_SUCCESS , WRITE_RESULT_WRONG_ADDRESS = ERR_WRONG_ADDRESS }; enum CONNECT_RESULT { CONNECT_RESULT_SUCCESS = ERR_SUCCESS , CONNECT_RESULT_WRONG_ADDRESS = ERR_WRONG_ADDRESS }; Good, because error types to expect are declared explicitly Good, because most values can be reused in error handling Bad, because of very long names due to missing namespace support in C Bad, because compiler does not really enforce the enum range","title":"005 Error codes definition"},{"location":"decisions/005-error-codes.html#005-error-codes-definition","text":"Status: accepted Deciders: partners","title":"005 Error codes definition"},{"location":"decisions/005-error-codes.html#context-and-problem-statement","text":"We need to define a common set of error codes for all API calls to enable better diagnostics in case of runtime errors.","title":"Context and Problem Statement"},{"location":"decisions/005-error-codes.html#decision-drivers","text":"??","title":"Decision Drivers"},{"location":"decisions/005-error-codes.html#decision-outcome","text":"Same error type for all methods","title":"Decision Outcome"},{"location":"decisions/005-error-codes.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/005-error-codes.html#same-error-type-for-all-methods","text":"e.g. typedef int SOUTH_API_RESULT ; #define SOUTH_API_SUCCESS 0 #define SOUTH_API_UNKNOWN_VARIABLE 1 #define SOUTH_API_WRONG_ADDRESS 2 Good, because this is the usual way of defining error codes in C Good, because this is directly supported in C Bad, because there is no diffentiation between different classes of api functions. Error codes to be expected have to be declared in comments.","title":"Same error type for all methods"},{"location":"decisions/005-error-codes.html#one-error-type-for-each-class-of-functions","text":"e.g. enum READ_RESULT { READ_RESULT_SUCCESS = 0 READ_RESULT_UNKNOWN = 1 }; enum WRITE_RESULT { WRITE_RESULT_SUCCESS = 0 WRITE_RESULT_WRONG_ADDRESS = 1 }; enum CONNECT_RESULT { CONNECT_RESULT_SUCCESS = 0 CONNECT_RESULT_WRONG_ADDRESS = 1 }; Good, because error types to expect are declared expicitely Bad, because of very long names due to missing namespace support in C Bad, because writing log messages becomes hard Bad, because error handling is case to case for each function","title":"One error type for each class of functions"},{"location":"decisions/005-error-codes.html#one-error-type-for-each-class-of-functions-but-the-error-codes-are-the-same","text":"e.g. #define ERR_SUCCESS 0 #define ERR_WRONG_ADDRESS 200 #define ERR_UNKNOWN_VARIABLE 300 enum READ_RESULT { READ_RESULT_SUCCESS = ERR_SUCCESS , READ_RESULT_UNKNOWN = ERR_UNKNOWN_VARIABLE }; enum WRITE_RESULT { WRITE_RESULT_SUCCESS = ERR_SUCCESS , WRITE_RESULT_WRONG_ADDRESS = ERR_WRONG_ADDRESS }; enum CONNECT_RESULT { CONNECT_RESULT_SUCCESS = ERR_SUCCESS , CONNECT_RESULT_WRONG_ADDRESS = ERR_WRONG_ADDRESS }; Good, because error types to expect are declared explicitly Good, because most values can be reused in error handling Bad, because of very long names due to missing namespace support in C Bad, because compiler does not really enforce the enum range","title":"One error type for each class of functions but the error codes are the same"},{"location":"decisions/006-text-encoding.html","text":"006 How should text values be encoded? Status: accepted Deciders: partners Context and Problem Statement When transfering text values and identifiers it is important to have a common meaning of the character values to avoid wrong presentation to the user and non matching identifiers. Decision outcome Arrays of char which represent text values are encoded as UTF-8. No plausible alternatives were presented. Pros and Cons of the Options ASCII or Latin1 Codepage Bad, because a limitation to a specific 8-bit charater set does not meet the requirements of modern internationalized software and is not compatible with the OPC-UA specification. UTF-8 Good, because not transcoding is needed when sending it to th OPC-UA server. UTF-16 Bad, because it consumes more memory. Bad, because 16 bit char type is not really compatible. UTF-32 Bad, because of even more memory consumption.","title":"006 How should text values be encoded?"},{"location":"decisions/006-text-encoding.html#006-how-should-text-values-be-encoded","text":"Status: accepted Deciders: partners","title":"006 How should text values be encoded?"},{"location":"decisions/006-text-encoding.html#context-and-problem-statement","text":"When transfering text values and identifiers it is important to have a common meaning of the character values to avoid wrong presentation to the user and non matching identifiers.","title":"Context and Problem Statement"},{"location":"decisions/006-text-encoding.html#decision-outcome","text":"Arrays of char which represent text values are encoded as UTF-8. No plausible alternatives were presented.","title":"Decision outcome"},{"location":"decisions/006-text-encoding.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/006-text-encoding.html#ascii-or-latin1-codepage","text":"Bad, because a limitation to a specific 8-bit charater set does not meet the requirements of modern internationalized software and is not compatible with the OPC-UA specification.","title":"ASCII or Latin1 Codepage"},{"location":"decisions/006-text-encoding.html#utf-8","text":"Good, because not transcoding is needed when sending it to th OPC-UA server.","title":"UTF-8"},{"location":"decisions/006-text-encoding.html#utf-16","text":"Bad, because it consumes more memory. Bad, because 16 bit char type is not really compatible.","title":"UTF-16"},{"location":"decisions/006-text-encoding.html#utf-32","text":"Bad, because of even more memory consumption.","title":"UTF-32"},{"location":"decisions/007-memory-allocation.html","text":"007 What are the rules for memory management? Status: accepted Deciders: partners Decisions Memory ownership is never transfered between TEK and DC. The interface partner which allocates memory is also responsible for freeing it. Memory ownership must not be mixed in data structures ... otherwise it could not be freed safely. The memory referenced by pointers which are passed to functions need not be valid longer than the function call. As consequence it is not feasible to copy pointers only for later use. If data needs to be persisted for later use, a deep copy is neccessary. If ever any exception from this rule is needed it must be documented explicitely. Memory passed to a function call is not modified from the caller while the function call is in progress. That means the caller is responsible for thread safety of passed memory. Memory passed to a function call is not modified from the callee, except it is explicitely allowed. The interface uses the const qualifier to mark unmodifiable memory. void pass_unmodifiable_memory ( field_data const * data )","title":"007 What are the rules for memory management?"},{"location":"decisions/007-memory-allocation.html#007-what-are-the-rules-for-memory-management","text":"Status: accepted Deciders: partners","title":"007 What are the rules for memory management?"},{"location":"decisions/007-memory-allocation.html#decisions","text":"","title":"Decisions"},{"location":"decisions/007-memory-allocation.html#memory-ownership-is-never-transfered-between-tek-and-dc","text":"The interface partner which allocates memory is also responsible for freeing it.","title":"Memory ownership is never transfered between TEK and DC."},{"location":"decisions/007-memory-allocation.html#memory-ownership-must-not-be-mixed-in-data-structures","text":"... otherwise it could not be freed safely.","title":"Memory ownership must not be mixed in data structures"},{"location":"decisions/007-memory-allocation.html#the-memory-referenced-by-pointers-which-are-passed-to-functions-need-not-be-valid-longer-than-the-function-call","text":"As consequence it is not feasible to copy pointers only for later use. If data needs to be persisted for later use, a deep copy is neccessary. If ever any exception from this rule is needed it must be documented explicitely.","title":"The memory referenced by pointers which are passed to functions need not be valid longer than the function call."},{"location":"decisions/007-memory-allocation.html#memory-passed-to-a-function-call-is-not-modified-from-the-caller-while-the-function-call-is-in-progress","text":"That means the caller is responsible for thread safety of passed memory.","title":"Memory passed to a function call is not modified from the caller while the function call is in progress."},{"location":"decisions/007-memory-allocation.html#memory-passed-to-a-function-call-is-not-modified-from-the-callee-except-it-is-explicitely-allowed","text":"The interface uses the const qualifier to mark unmodifiable memory. void pass_unmodifiable_memory ( field_data const * data )","title":"Memory passed to a function call is not modified from the callee, except it is explicitely allowed."},{"location":"decisions/008-configuration-structure.html","text":"008 What are the common requirements for the data client configuration? Status: accepted Deciders: partners Assumptions A data client should not access the file system directly The TEK reads the configuration from a TEK specific storage and forward it to the data client The TEK is responsible to identify the correct plugin for the each configuration file Different vendors may already supply configuration files in proprietary formats. The DC configuration of a specific client should be the same for different implementations of the TEK. The configuration of the TEK itself may be implementation specific. The complete data client configuration and data client \"discovery\" configuration must be compatible between alle TEK implementations. OS specific limitations may restrict the location of shared libraries and configuration files. Decision Separated configuration files of TEK and Plugins Separated configuration files of plugin and data clients Data client configurations are not necessarily nested below plugin configurations Ideas The TEK uses different directories for data client shared libraries and data client configuration. The directory structure for the binaries is implementation specific to the TEK implementation. The structure of the configuration on the other side is equal in all TEK implementations. Possible configuration structure - does not influence the south api All plugin configurations are in a subdirectory 'data_client:plugins' Each Plugin has its own subdirectory. Its name is not constrained. Each plugin configuration directory contains a 'plugin.json' All client/device configurations are in a subdirectory 'data_clients' Each client has its own subdirectory. Its name is not constrained. Each client directory contains a client.json configuration file. A client.json or plugin.json can contain references to additional files. example/proposal of the directory structure .../binaries/ | + data_client_plugins/ | + dc-s7.dll + dc-ads.dll .../configuration/ | + data_clients/ | | | + NC/ | | | | | + client.json | + PLC/ | | | | | + client.json | | + symbols.xml // Siemens specific | + data_client_plugins/ | + siemens-s7 | + plugin.json // TEK-Spec conformant | + lic.bin // Siemens specific + beckhoff-ads/ | + plugin.json // plugi n .jso n { \"tek.plugin-name\" : \"Siemens Step7\" , \"tek.plugin-library\" : \"dc-s7\" , // loads dc - s 7. so resp. dc - s 7. dll \"tek.additional-files\" : { \"secret-license-file\" : \"lic.bin\" } // op t io nal plugi n speci f ic proper t ies } // clie nt .jso n { \"tek.plugin\" : \"siemens-s7\" , // re feren ces direc t ory i ns ide da ta _clie nt _plugi ns \"tek.additional-files\" : { \"symbols\" : \"symbols.xml\" } // ... op t io nal plugi n a n d clie nt speci f ic proper t ies } struct additional_file { char * name ; // name of additional file char * content ; // content of additional file }; struct configuration { char * config ; // json content additional_file * additional_files ; size_t additional_files_count ; }; Configuration options TEK and plugins one common configuration file for tek and data client Bad, because ist may be large and hard to edit. Bad, because the configuration of the data clients can not be copied to another TEK without modifications different configuration files for tek and data client Good Plugin and data client different configuration for plugin and device Good combined configuration of plugin and device Bad, because it is not easy to disable a device Plugin and data client hierarchy device configuration below plugin configuration Bad, because a single device can not be copied/moved between different TEKs. device configuration in own directory Good, because naming conflicts are impossible","title":"008 What are the common requirements for the data client configuration?"},{"location":"decisions/008-configuration-structure.html#008-what-are-the-common-requirements-for-the-data-client-configuration","text":"Status: accepted Deciders: partners","title":"008 What are the common requirements for the data client configuration?"},{"location":"decisions/008-configuration-structure.html#assumptions","text":"A data client should not access the file system directly The TEK reads the configuration from a TEK specific storage and forward it to the data client The TEK is responsible to identify the correct plugin for the each configuration file Different vendors may already supply configuration files in proprietary formats. The DC configuration of a specific client should be the same for different implementations of the TEK. The configuration of the TEK itself may be implementation specific. The complete data client configuration and data client \"discovery\" configuration must be compatible between alle TEK implementations. OS specific limitations may restrict the location of shared libraries and configuration files.","title":"Assumptions"},{"location":"decisions/008-configuration-structure.html#decision","text":"Separated configuration files of TEK and Plugins Separated configuration files of plugin and data clients Data client configurations are not necessarily nested below plugin configurations","title":"Decision"},{"location":"decisions/008-configuration-structure.html#ideas","text":"The TEK uses different directories for data client shared libraries and data client configuration. The directory structure for the binaries is implementation specific to the TEK implementation. The structure of the configuration on the other side is equal in all TEK implementations.","title":"Ideas"},{"location":"decisions/008-configuration-structure.html#possible-configuration-structure-does-not-influence-the-south-api","text":"All plugin configurations are in a subdirectory 'data_client:plugins' Each Plugin has its own subdirectory. Its name is not constrained. Each plugin configuration directory contains a 'plugin.json' All client/device configurations are in a subdirectory 'data_clients' Each client has its own subdirectory. Its name is not constrained. Each client directory contains a client.json configuration file. A client.json or plugin.json can contain references to additional files. example/proposal of the directory structure .../binaries/ | + data_client_plugins/ | + dc-s7.dll + dc-ads.dll .../configuration/ | + data_clients/ | | | + NC/ | | | | | + client.json | + PLC/ | | | | | + client.json | | + symbols.xml // Siemens specific | + data_client_plugins/ | + siemens-s7 | + plugin.json // TEK-Spec conformant | + lic.bin // Siemens specific + beckhoff-ads/ | + plugin.json // plugi n .jso n { \"tek.plugin-name\" : \"Siemens Step7\" , \"tek.plugin-library\" : \"dc-s7\" , // loads dc - s 7. so resp. dc - s 7. dll \"tek.additional-files\" : { \"secret-license-file\" : \"lic.bin\" } // op t io nal plugi n speci f ic proper t ies } // clie nt .jso n { \"tek.plugin\" : \"siemens-s7\" , // re feren ces direc t ory i ns ide da ta _clie nt _plugi ns \"tek.additional-files\" : { \"symbols\" : \"symbols.xml\" } // ... op t io nal plugi n a n d clie nt speci f ic proper t ies } struct additional_file { char * name ; // name of additional file char * content ; // content of additional file }; struct configuration { char * config ; // json content additional_file * additional_files ; size_t additional_files_count ; };","title":"Possible configuration structure - does not influence the south api"},{"location":"decisions/008-configuration-structure.html#configuration-options","text":"","title":"Configuration options"},{"location":"decisions/008-configuration-structure.html#tek-and-plugins","text":"","title":"TEK and plugins"},{"location":"decisions/008-configuration-structure.html#one-common-configuration-file-for-tek-and-data-client","text":"Bad, because ist may be large and hard to edit. Bad, because the configuration of the data clients can not be copied to another TEK without modifications","title":"one common configuration file for tek and data client"},{"location":"decisions/008-configuration-structure.html#different-configuration-files-for-tek-and-data-client","text":"Good","title":"different configuration files for tek and data client"},{"location":"decisions/008-configuration-structure.html#plugin-and-data-client","text":"","title":"Plugin and data client"},{"location":"decisions/008-configuration-structure.html#different-configuration-for-plugin-and-device","text":"Good","title":"different configuration for plugin and device"},{"location":"decisions/008-configuration-structure.html#combined-configuration-of-plugin-and-device","text":"Bad, because it is not easy to disable a device","title":"combined configuration of plugin and device"},{"location":"decisions/008-configuration-structure.html#plugin-and-data-client-hierarchy","text":"","title":"Plugin and data client hierarchy"},{"location":"decisions/008-configuration-structure.html#device-configuration-below-plugin-configuration","text":"Bad, because a single device can not be copied/moved between different TEKs.","title":"device configuration below plugin configuration"},{"location":"decisions/008-configuration-structure.html#device-configuration-in-own-directory","text":"Good, because naming conflicts are impossible","title":"device configuration in own directory"},{"location":"decisions/009-data-client-model-access.html","text":"009 data client model access Status: accepted Deciders: partners Context and Problem Statement TEK implementations need to know the model and capabilities of a data client. i.e. which fields can be read, are there any events which can be emitted by the data client or which alarms and conditions are provided. This data model of a data client is needed to know what to expect from the data client at runtime and to validate script interactions with a given data client. Decision Drivers simplicity: the execution flow ist easily understandable understandability: how ist this problem solved in other similar contexts (e.g. data binding in OPC-UA SDK's or data access in known PLC access libraries) extensibility, upgradability: how easy and backwards compatible can new features be integrated usability: how easily can errors in the custom scrips and in the configuration be detected Considered Options TEK reads data client model/capabilities directly from data client data client registers model at TEK Decision Outcome data client registers model at TEK Pros and Cons of the Options TEK reads data client model/capabilities directly from data client The data client implements methods for all relevant model parts which are used by the TEK. interface south_api { List < field > get_declared_field (); List < field > get_declared_events (); }; Good, because the execution flow is easily understandable (less usage of callback functions) Good, because the interface is easier to read and understand Bad, because data clients must implement functions for model parts which are not supported by a specific data client (i.e. events might not be of interest) Bad, because it may be unclear which functionality in the DC is mandatory and which is optional data client registers model at TEK The TEK interface contains method definitions for registering fields, events and other model parts. With this option a data client can decide which model it actively must support and is not forced to implement empty functions. interface tek { // ... RESULT register_field ( data_client , field , type ); RESULT register_event ( data_client , event ); // ... }; A data client implements a single method register containing code responsible for registering all model related parts at the TEK. interface data_client { RESULT register ( tek ); } Good, because the data client must not implement code for not used model parts Good, because the interface can be extended in a way that existing DC can be reused without modification Good, because it is assumed that the required amount of code in the DC is smaller Bad, because the data client implementor must deal with function pointers","title":"009 data client model access"},{"location":"decisions/009-data-client-model-access.html#009-data-client-model-access","text":"Status: accepted Deciders: partners","title":"009 data client model access"},{"location":"decisions/009-data-client-model-access.html#context-and-problem-statement","text":"TEK implementations need to know the model and capabilities of a data client. i.e. which fields can be read, are there any events which can be emitted by the data client or which alarms and conditions are provided. This data model of a data client is needed to know what to expect from the data client at runtime and to validate script interactions with a given data client.","title":"Context and Problem Statement"},{"location":"decisions/009-data-client-model-access.html#decision-drivers","text":"simplicity: the execution flow ist easily understandable understandability: how ist this problem solved in other similar contexts (e.g. data binding in OPC-UA SDK's or data access in known PLC access libraries) extensibility, upgradability: how easy and backwards compatible can new features be integrated usability: how easily can errors in the custom scrips and in the configuration be detected","title":"Decision Drivers"},{"location":"decisions/009-data-client-model-access.html#considered-options","text":"TEK reads data client model/capabilities directly from data client data client registers model at TEK","title":"Considered Options"},{"location":"decisions/009-data-client-model-access.html#decision-outcome","text":"data client registers model at TEK","title":"Decision Outcome"},{"location":"decisions/009-data-client-model-access.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/009-data-client-model-access.html#tek-reads-data-client-modelcapabilities-directly-from-data-client","text":"The data client implements methods for all relevant model parts which are used by the TEK. interface south_api { List < field > get_declared_field (); List < field > get_declared_events (); }; Good, because the execution flow is easily understandable (less usage of callback functions) Good, because the interface is easier to read and understand Bad, because data clients must implement functions for model parts which are not supported by a specific data client (i.e. events might not be of interest) Bad, because it may be unclear which functionality in the DC is mandatory and which is optional","title":"TEK reads data client model/capabilities directly from data client"},{"location":"decisions/009-data-client-model-access.html#data-client-registers-model-at-tek","text":"The TEK interface contains method definitions for registering fields, events and other model parts. With this option a data client can decide which model it actively must support and is not forced to implement empty functions. interface tek { // ... RESULT register_field ( data_client , field , type ); RESULT register_event ( data_client , event ); // ... }; A data client implements a single method register containing code responsible for registering all model related parts at the TEK. interface data_client { RESULT register ( tek ); } Good, because the data client must not implement code for not used model parts Good, because the interface can be extended in a way that existing DC can be reused without modification Good, because it is assumed that the required amount of code in the DC is smaller Bad, because the data client implementor must deal with function pointers","title":"data client registers model at TEK"},{"location":"decisions/010-opc-ua-data-source-integration.html","text":"010 OPC UA data source integration Status: accepted Deciders: partners Context and Problem Statement There are potential existing data sources already providing an OPC UA interface. Here we want to outline how integration of OPC UA data sources can be accomplished and if these are treated differently to other data clients due to the higher complexity of OPC UA. Decision Drivers portability: consider consequences of feature parity between OPC UA and South API for involved parties Considered Options mapping to South API and back to North API/OPC UA with already outlined functionality assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration Decision Outcome As long as the OPC UA data client does not require more functionality than the south API provides, there is no reason to use another API than the South API. If there are additional requirements that do not match the intention and structure of the South API or would lead to an increased complexity for other data clients, than fallback to option: assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration Pros and Cons of the Options Since no immediate action is required for the chosen option it is still possible to revert this decision without having spent effort and chose to integrate OPC UA data sources with South API compatible data clients. mapping to South API and back to North API/OPC UA with already outlined functionality Good, because only a single data source integration via South API must be implemented by transformation engines Bad, because feature parity between South API and OPC UA or between a OPC UA feature subset must be considered and potential limitations must be defined and might limit usability of existing data sources Bad, because even if direct OPC UA knowledge is not required by data client implementors it might still \"leak through\" via South API specifications assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration Good, South API must not enable full feature set of OPC UA Good, because transformation engine implementors should already be familiar with OPC UA features Bad, because transformation engine implementations must handle an additional data source type","title":"010 OPC UA data source integration"},{"location":"decisions/010-opc-ua-data-source-integration.html#010-opc-ua-data-source-integration","text":"Status: accepted Deciders: partners","title":"010 OPC UA data source integration"},{"location":"decisions/010-opc-ua-data-source-integration.html#context-and-problem-statement","text":"There are potential existing data sources already providing an OPC UA interface. Here we want to outline how integration of OPC UA data sources can be accomplished and if these are treated differently to other data clients due to the higher complexity of OPC UA.","title":"Context and Problem Statement"},{"location":"decisions/010-opc-ua-data-source-integration.html#decision-drivers","text":"portability: consider consequences of feature parity between OPC UA and South API for involved parties","title":"Decision Drivers"},{"location":"decisions/010-opc-ua-data-source-integration.html#considered-options","text":"mapping to South API and back to North API/OPC UA with already outlined functionality assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration","title":"Considered Options"},{"location":"decisions/010-opc-ua-data-source-integration.html#decision-outcome","text":"As long as the OPC UA data client does not require more functionality than the south API provides, there is no reason to use another API than the South API. If there are additional requirements that do not match the intention and structure of the South API or would lead to an increased complexity for other data clients, than fallback to option: assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration","title":"Decision Outcome"},{"location":"decisions/010-opc-ua-data-source-integration.html#pros-and-cons-of-the-options","text":"Since no immediate action is required for the chosen option it is still possible to revert this decision without having spent effort and chose to integrate OPC UA data sources with South API compatible data clients.","title":"Pros and Cons of the Options"},{"location":"decisions/010-opc-ua-data-source-integration.html#mapping-to-south-api-and-back-to-north-apiopc-ua-with-already-outlined-functionality","text":"Good, because only a single data source integration via South API must be implemented by transformation engines Bad, because feature parity between South API and OPC UA or between a OPC UA feature subset must be considered and potential limitations must be defined and might limit usability of existing data sources Bad, because even if direct OPC UA knowledge is not required by data client implementors it might still \"leak through\" via South API specifications","title":"mapping to South API and back to North API/OPC UA with already outlined functionality"},{"location":"decisions/010-opc-ua-data-source-integration.html#assume-a-south-api-independent-direct-connection-from-opc-ua-data-sources-to-north-bound-opc-ua-to-be-defined-in-later-iteration","text":"Good, South API must not enable full feature set of OPC UA Good, because transformation engine implementors should already be familiar with OPC UA features Bad, because transformation engine implementations must handle an additional data source type","title":"assume a South API independent direct connection from OPC UA data sources to north bound OPC UA to be defined in later iteration"},{"location":"decisions/011-metadata.html","text":"011 Metadata Status: WIP Deciders: tbd. Context and Problem Statement The data source contains metadata information about its variables such as range or engineering units. The South API should provide the means to transport the information to the TEK. The TEK may expose the information in a OPC UA compliant fashion through the North API in the OPC UA server. For example, the range of a variable is encoded as AnalogItem in the OPC UA server exposing the range information using OPC UA datatype \"Range\" in the property \"EURange\" of the variable. In addition, TEK scripts may use the information to perform specific actions. For example, an event may be fired when a data point is not in its range (metadata range information) or a temperature will always be converted to Celsius. A variable may contain structured data. The API should allow to associate metadata with some fields, for example, the member 'temperature' of the struct has unit '\u00b0 Celsius'. The API should provide the means for the TEK to identify which metadata of a variable is associated with each read of the variable, i.e., data point at time X was a temperature in Celsius, data point at time Y was a temperature in Fahrenheit. Decision Drivers Define the means to transport the same metadata information, e.g. unit, from multiple data clients uniformly to the TEK Allow extension of additional metadata \"types\" without breaking the API or ABI Considered Options Option 1: meta data content struct provided as parameter for \"register_field\" method and as part of \"tek_sa_struct_field_type_definition\" The API will expose a metadata struct that contains the metadata information that can be set by data client. The metadata are set during register field. struct tek_sa_metadata { double range_min ; double range_max ; const char * unit ; }; struct tek_sa_api { // ... TEK_SA_RESULT ( * register_field )( tek_sa_data_client_handle dc , const char * name , enum tek_sa_field_attributes attributes , enum tek_sa_variant_type type , tek_sa_field_handle * new_field_handle , struct tek_sa_metadata const * metadata ); // ... }; Option 2: key/value pair solution without semantic The data client can set the metadata using a metadata key and a value per field. To remove a metadata information a null value can be set. struct tek_sa_api { void update_metadata ( data_client_handle dc , field_handle fh , tek_metadata_key key , struct tek_sa_variant const * value ); }; The key may be predefined values, e.g. int with different constants, or a name with optional reserved strings, e.g. \"RANGE_MIN\", \"RANGE_MAX\". // with int constants typedef int tek_metadata_key ; #define TEK_METADATA_KEY_RANGE_MIN 1 #define TEK_METADATA_KEY_RANGE_MAX 2 #define TEK_METADATA_KEY_UNIT 3 // with string constants typedef char * tek_metadata_key ; const char * TEK_METADATA_KEY_RANGE_MIN \"RANGE_MIN\" ; const char * TEK_METADATA_KEY_RANGE_MAX \"RANGE_MAX\" ; const char * TEK_METADATA_KEY_UNIT \"RANGE_UNIT\" ; TODO clarify when the update_metadata function should or must be called. Decision Outcome tbd. Pros and Cons of the Options Option 1 Good, because metadata can be set at simply and unambiguously in through the struct. Bad, because adding new metadata types breaks the API. Bad, because metadata information may not yet be available when register_field is called. Metadata may only be available when the data client is connected to the data source. Bad, because metadata information cannot be updated. Bad, because metadata cannot be stored for a member of a struct. Option 2 Good, because extending new metadata types do not break the API. Good, because updating metadata can be performed during execution of the TEK. Bad, because data client may use keys that are not known to the TEK.","title":"011 Metadata"},{"location":"decisions/011-metadata.html#011-metadata","text":"Status: WIP Deciders: tbd.","title":"011 Metadata"},{"location":"decisions/011-metadata.html#context-and-problem-statement","text":"The data source contains metadata information about its variables such as range or engineering units. The South API should provide the means to transport the information to the TEK. The TEK may expose the information in a OPC UA compliant fashion through the North API in the OPC UA server. For example, the range of a variable is encoded as AnalogItem in the OPC UA server exposing the range information using OPC UA datatype \"Range\" in the property \"EURange\" of the variable. In addition, TEK scripts may use the information to perform specific actions. For example, an event may be fired when a data point is not in its range (metadata range information) or a temperature will always be converted to Celsius. A variable may contain structured data. The API should allow to associate metadata with some fields, for example, the member 'temperature' of the struct has unit '\u00b0 Celsius'. The API should provide the means for the TEK to identify which metadata of a variable is associated with each read of the variable, i.e., data point at time X was a temperature in Celsius, data point at time Y was a temperature in Fahrenheit.","title":"Context and Problem Statement"},{"location":"decisions/011-metadata.html#decision-drivers","text":"Define the means to transport the same metadata information, e.g. unit, from multiple data clients uniformly to the TEK Allow extension of additional metadata \"types\" without breaking the API or ABI","title":"Decision Drivers"},{"location":"decisions/011-metadata.html#considered-options","text":"","title":"Considered Options"},{"location":"decisions/011-metadata.html#option-1-meta-data-content-struct-provided-as-parameter-for-register_field-method-and-as-part-of-tek_sa_struct_field_type_definition","text":"The API will expose a metadata struct that contains the metadata information that can be set by data client. The metadata are set during register field. struct tek_sa_metadata { double range_min ; double range_max ; const char * unit ; }; struct tek_sa_api { // ... TEK_SA_RESULT ( * register_field )( tek_sa_data_client_handle dc , const char * name , enum tek_sa_field_attributes attributes , enum tek_sa_variant_type type , tek_sa_field_handle * new_field_handle , struct tek_sa_metadata const * metadata ); // ... };","title":"Option 1: meta data content struct provided as parameter for \"register_field\" method and as part of \"tek_sa_struct_field_type_definition\""},{"location":"decisions/011-metadata.html#option-2-keyvalue-pair-solution-without-semantic","text":"The data client can set the metadata using a metadata key and a value per field. To remove a metadata information a null value can be set. struct tek_sa_api { void update_metadata ( data_client_handle dc , field_handle fh , tek_metadata_key key , struct tek_sa_variant const * value ); }; The key may be predefined values, e.g. int with different constants, or a name with optional reserved strings, e.g. \"RANGE_MIN\", \"RANGE_MAX\". // with int constants typedef int tek_metadata_key ; #define TEK_METADATA_KEY_RANGE_MIN 1 #define TEK_METADATA_KEY_RANGE_MAX 2 #define TEK_METADATA_KEY_UNIT 3 // with string constants typedef char * tek_metadata_key ; const char * TEK_METADATA_KEY_RANGE_MIN \"RANGE_MIN\" ; const char * TEK_METADATA_KEY_RANGE_MAX \"RANGE_MAX\" ; const char * TEK_METADATA_KEY_UNIT \"RANGE_UNIT\" ; TODO clarify when the update_metadata function should or must be called.","title":"Option 2: key/value pair solution without semantic"},{"location":"decisions/011-metadata.html#decision-outcome","text":"tbd.","title":"Decision Outcome"},{"location":"decisions/011-metadata.html#pros-and-cons-of-the-options","text":"","title":"Pros and Cons of the Options"},{"location":"decisions/011-metadata.html#option-1","text":"Good, because metadata can be set at simply and unambiguously in through the struct. Bad, because adding new metadata types breaks the API. Bad, because metadata information may not yet be available when register_field is called. Metadata may only be available when the data client is connected to the data source. Bad, because metadata information cannot be updated. Bad, because metadata cannot be stored for a member of a struct.","title":"Option 1"},{"location":"decisions/011-metadata.html#option-2","text":"Good, because extending new metadata types do not break the API. Good, because updating metadata can be performed during execution of the TEK. Bad, because data client may use keys that are not known to the TEK.","title":"Option 2"}]}